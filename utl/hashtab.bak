{*******************************************************************************
*                                                                              *
* Hash table generator                                                         *
*                                                                              *
* Generates tight chained tables for use with as. The output table is in the   *
* form of assignment to a 'ressym' array, suitable for direct insertion.       *
* The program should be executed as:                                           *
*                                                                              *
*    hashtab file                                                              *
*                                                                              *
* The input should be in file.lab. It is a collection of labels, one per       *
* line. The resulting table will be output in the text file file.res, in the   *
* form of a type definition for opcode, and the full assignments to the        *
* ressym array.                                                                *
* Anywhere on the input lines, a comment may appear, preceded by a '!' mark.   *
* lines that are blank, or contain a comment only, are ignored.                *
*                                                                              *
* Note that labels greater than 9 characters are truncated.                    *
*                                                                              *
*******************************************************************************}

program hashtab(output);

uses stddef; { standard definitions }

label 99;

const tabmax = 1000; { maximum table length }
      maxfil = 20;   { number of characters in a file name }
      maxlin = 200;  { number of characters in input line }
      maxext = 4;    { number of characters in file extention }
      maxlab = 10;   { number of characters in label }
      cmdmax = 250;  { maximum length of command string }

type filinx = 1..maxfil; { index for filenames }
     filnam = packed array [filinx] of char; { filename }
     lininx = 1..maxlin; { index for text line }
     line   = packed array [lininx] of char; { text line }
     extinx = 1..maxext; { index for file extention }
     extbuf = packed array [extinx] of char; { buffer for extention }
     labinx = 1..maxlab; { index for label }
     name = packed array[labinx] of char;

var loadarr: array [1..tabmax] of name; { holding table }
    duparr:  array [1..tabmax] of boolean; { duplicates table }
    dupflg:  boolean; { duplicates were flagged }
    ressym: array [1..tabmax] of { label table }
               record
                  reslab: name;
                  reschn: 0..tabmax { chain }
               end;
    max: 0..65535; { maximum number of entries }
    s : name;
    i, x, h: 0..tabmax; { indexes }
    lc: byte; { character on line count }
    labfil: text; { label input file }
    deffil: text; { result table file }
    inifil: text; { initalization file }
    labsiz: 0..maxlab; { maximum label size }
    labc:   0..maxlab; { label size counter }

{*******************************************************************************

Check digit

Checks wether the given character lies in the set ['0'..'9'].
Returns the status.

*******************************************************************************}

function digit(c: char)  { character to check }
              : boolean; { status of check }

begin

   digit := c in ['0'..'9']

end;

{*******************************************************************************

Check alphabetical

Checks if the given character lies in the set
['A'..'Z', 'a'..'z'] (is a letter). Returns the status.

*******************************************************************************}

function alpha(c : char) { character to check }
              : boolean; { status }

begin

   alpha := c in ['A'..'Z', 'a'..'z']

end;

{*******************************************************************************

Append file extention

Appends a given extention, in place, to the given file name.
The extention is usually in the form: '.ext'. The extention is
placed within the file name at the first space or period from
the left hand side. This allows extention of either an
unextended filename or an extended one (in which case the new
extention simply overlays the old). The overlay is controlled
via flag: if overwrite is true, the extention will overwrite
any existing, if not, any existing extention will be left in
place.

Note: this routine is CP/M dependant.

*******************************************************************************}

procedure addext(var str:    filnam;   { filename to extend }
                     ext:    extbuf;   { filename extention }
                     extend: boolean); { overwrite flag }

var i: filinx; { filename index }
    x: extinx; { label index }

begin

   i := 1; { initalize index }
   { skip to first character ' ' or '.' }
   while (str[i] <> ' ') and (str[i] <> '.') do i := succ(i);
   if extend or (str[i] = ' ') then
      for x := 1 to maxext do { append file extention }
         if ext[x] <> ' ' then begin { append non - space characters }

         str[i] := ext[x]; { transfer extention character }
         i := succ(i) { count }

      end

end;

{*******************************************************************************

Input string from label file

*******************************************************************************}

procedure inpstr(var str: name);

var i:       integer;
    comment: boolean;
    c:       char;

begin

   comment := false; { set not in comment mode }
   for i := 1 to 10 do str[i] := ' ';
   i := 1;
   while not eoln(labfil) do begin

      read(labfil, c); { get next character }
      if i < maxlab then begin { still valid label }

         if c = '!' then comment := true; { set in comment mode }
         if comment then c := ' '; { if comment on, clear output }
         str[i] := c; { place character }
         i := i + 1

      end

   end;
   readln(labfil)

end;

{*******************************************************************************

Hash label

*******************************************************************************}

function hash(s: name): byte;

var i, r : integer;

begin

   r := 0;
   for i := 1 to 10 do if s[i] <> ' ' then r := r + ord(s[i]);
   hash := r mod max + 1

end;

{*******************************************************************************

Output opcode type

Outputs the opcode enumerated type. The entries are packed to fit on a line.

*******************************************************************************}

procedure wrtopc;

var i, x:  0..tabmax; { index for table }
    lc:    byte;      { character on line count }
begin

   writeln(deffil, '{ Opcode type.');
   writeln(deffil);
   writeln(deffil, '  Note: the entries opnull and oplast mark the start and end of the table,');
   writeln(deffil, '        respectively, and don''t represent actual opcodes. }');
   writeln(deffil);
   { output opcode type }
   write(deffil, 'type  opcodet = (opnull,');
   lc := 23; { set character position }
   for i := 1 to max do begin { output names }

      write(deffil, 'op'); { preamble }
      lc := lc+2;
      for x := 1 to 10 do if ressym[i].reslab[x] <> ' ' then begin

         write(deffil, ressym[i].reslab[x]);
         lc := lc + 1

      end;
      if i <> max then begin

         write(deffil, ',');
         lc := lc + 1;
         if lc > 60 then begin { line overflow }

            writeln(deffil);
            write(deffil, '                 ');
            lc := 15

         end

      end

   end;
   writeln(deffil, ',oplast);')

end;

{*******************************************************************************

Write definition file

*******************************************************************************}

procedure wrtdef;

begin

   writeln(deffil, '{*******************************************************************************');
   writeln(deffil, '*                                                                              *');
   writeln(deffil, '*                          OPCODE DEFINITION MODULE                            *');
   writeln(deffil, '*                                                                              *');
   writeln(deffil, '*                       Copyright (C) 2006 S. A. Moore                         *');
   writeln(deffil, '*                            All rights reserved                               *');
   writeln(deffil, '*                                                                              *');
   writeln(deffil, '* PURPOSE:                                                                     *');
   writeln(deffil, '*                                                                              *');
   writeln(deffil, '* Defines the opcodes for this assembler module.                               *');
   writeln(deffil, '*                                                                              *');
   writeln(deffil, '* WARNING: *** THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY ***         *');
   writeln(deffil, '*                                                                              *');
   writeln(deffil, '* This file is generated by hastab from the input file opcode.lab. It defines  *');
   writeln(deffil, '* the opcodet type, which is an enumerated list of all opcodesin use,          *');
   writeln(deffil, '* including the assembler directives in use.                                   *');
   writeln(deffil, '*                                                                              *');
   writeln(deffil, '* CREATING:                                                                    *');
   writeln(deffil, '*                                                                              *');
   writeln(deffil, '* To create this file, run hashtab in this directory.                          *');
   writeln(deffil, '*                                                                              *');
   writeln(deffil, '*******************************************************************************}');
   writeln(deffil);
   writeln(deffil, 'module opcdef;');
   writeln(deffil);
   wrtopc; { write out opcode type }
   writeln(deffil);
   writeln(deffil, 'begin');
   writeln(deffil, 'end.');

end;

{*******************************************************************************

Write reserved symbol table initialization

*******************************************************************************}

procedure wrtres;

var i: 0..tabmax; { index for reserved table }
    x: labinx;    { index for label }

begin

   writeln(inifil, '   { labels }');
   writeln(inifil);
   for i := 1 to max do begin { output result table }

      write(inifil, '   labcpy(ressym[op');
      for x := 1 to labsiz do write(inifil, ressym[i].reslab[x]);
      write(inifil, '].reslab, ''');
      for x := 1 to 10 do write(inifil, ressym[i].reslab[x]);
      writeln(inifil, ''');')

   end;
   writeln(inifil);
   writeln(inifil, '   { chains }');
   writeln(inifil);
   for i := 1 to max do begin { output result table }

      if ressym[i].reschn <> 0 then begin { output chaining spec }

         write(inifil, '   ressym[op'); 
         for x := 1 to labsiz do write(inifil, ressym[i].reslab[x]);
         write(inifil, '].reschn := op');
         for x := 1 to 10 do 
            if ressym[ressym[i].reschn].reslab[x] <> ' ' then 
               write(inifil, ressym[ressym[i].reschn].reslab[x]);
         writeln(inifil, ';')

      end

   end

end;

{*******************************************************************************

Write initialization file

*******************************************************************************}

procedure wrtini;

begin { hash }

   writeln(inifil, '{*******************************************************************************');
   writeln(inifil, '*                                                                              *');
   writeln(inifil, '*                         OPCODE INITIALIZATION MODULE                         *');
   writeln(inifil, '*                                                                              *');
   writeln(inifil, '*                       Copyright (C) 2006 S. A. Moore                         *');
   writeln(inifil, '*                            All rights reserved                               *');
   writeln(inifil, '*                                                                              *');
   writeln(inifil, '* PURPOSE:                                                                     *');
   writeln(inifil, '*                                                                              *');
   writeln(inifil, '* Defines the opcodes for this assembler module.                               *');
   writeln(inifil, '*                                                                              *');
   writeln(inifil, '* WARNING: *** THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY ***         *');
   writeln(inifil, '*                                                                              *');
   writeln(inifil, '* This file is generated by hastab from the input file opcode.lab. It defines  *');
   writeln(inifil, '* the resini procedure, that initializes the reserved word table.              *');
   writeln(inifil, '*                                                                              *');
   writeln(inifil, '* CREATING:                                                                    *');
   writeln(inifil, '*                                                                              *');
   writeln(inifil, '* To create this file, run hashtab in this directory.                          *');
   writeln(inifil, '*                                                                              *');
   writeln(inifil, '*******************************************************************************}');
   writeln(inifil);
   writeln(inifil, 'module opcini;');
   writeln(inifil);
   writeln(inifil, 'uses utl,    { assembly support routines }');
   writeln(inifil, '     opcdef, { opcode definition }');
   writeln(inifil, '     macdef; { machine specific definition }');
   writeln(inifil);
   writeln(inifil, 'var ressym: restab; { reserved symbols table }');
   writeln(inifil);
   writeln(inifil, '{*******************************************************************************');
   writeln(inifil, '                                                                                ');
   writeln(inifil, 'Initalize reserved word table                                                   ');
   writeln(inifil, '                                                                                ');
   writeln(inifil, 'The reserved word table is an array of records, with each record containing a   ');
   writeln(inifil, 'label, and a entry chain. The label is the actual reserved word itself. The     ');
   writeln(inifil, 'chain is an index into the reserved word table itself. Each position (index) in '); 
   writeln(inifil, 'the reserved word table corresponds to a ''hash'' value for a given label. The    ');
   writeln(inifil, 'hash value is a random function derived for the label that gives some level     ');
   writeln(inifil, '(typ > 90%) of ''uniqueness'' for a given label (see the ''hash'' routine for       ');
   writeln(inifil, 'details of the process). Each ''prime'' label occupys the entry cooresponding to  ');
   writeln(inifil, 'it''s hash value (a prime entry means that it is the first label for the hash    ');
   writeln(inifil, 'value to be placed). Duplicate entrys are placed in locations that have no      ');
   writeln(inifil, 'prime label. The chain fields then point to these labels succesively from the   ');
   writeln(inifil, 'prime entry, terminated with 0. A lookup is performed by succesively examining  ');
   writeln(inifil, 'each label in a chain, starting with the prime label, until a match is found    ');
   writeln(inifil, 'or the end of a chain is reached.                                               ');
   writeln(inifil, '                                                                                ');
   writeln(inifil, 'This routine sets up the labels and chain fields making up the table. The table '); 
   writeln(inifil, 'should already be cleared.                                                      ');
   writeln(inifil, '                                                                                ');
   writeln(inifil, '*******************************************************************************}');
   writeln(inifil);
   writeln(inifil, 'procedure resini;');
   writeln(inifil);
   writeln(inifil, 'begin');
   writeln(inifil);
   wrtres; { write out reserved table definitions }
   writeln(inifil);
   writeln(inifil, 'end;');
   writeln(inifil);
   writeln(inifil, 'begin');
   writeln(inifil, 'end.');

end;

begin { hash }

   writeln;
   writeln('Hash table generator vs. 3.0.02 Copyright (C) 2005 S. A. Moore');
   writeln;

   if not exists('opcode.lab') then begin { not found }

      writeln('*** Input symbol file does not exist');
      goto 99

   end;
   assign(labfil, 'opcode.lab'); { open label file }
   reset(labfil);
   assign(deffil, 'opcdef.pas'); { open output file }
   rewrite(deffil);
   assign(inifil, 'opcini.pas'); { open output file }
   rewrite(inifil);

   for i := 1 to tabmax do begin { clear save and result tables }

      loadarr[i] := '          ';
      ressym[i].reslab := '          ';
      ressym[i].reschn := 0

   end;
   i := 1; { index table start }
   while not eof(labfil) do begin { read labels }

      inpstr(s);
      if i = tabmax then begin { overflow }

         writeln('Maximum number of entries exceeded');
         goto 99

      end;
      if s <> '          ' then begin

         loadarr[i] := s; { place next symbol }
         i := i + 1 { next entry }

      end

   end;
   max := i-1; { set maximum number of entries }
   { check for duplicates }
   dupflg := false; { clear duplicates found flag }
   for i := 1 to max do duparr[i] := false; { clear duplicates flags }
   { scan for duplicates }
   for i := 1 to max do
      for x := 1 to max do begin

         if (loadarr[i] = loadarr[x]) and (i <> x) then begin

            { found a duplicate }
            if not duparr[i] then { not already flagged as a duplicate }
               writeln('*** Warning: Duplicate found: ', loadarr[i]:0);
            duparr[i] := true; { set duplicate on both entries }
            duparr[x] := true;
            dupflg := true { flag there were duplicates }

         end

      end;
   if dupflg then begin

      writeln;
      writeln('*** Notice: Duplicates were found. The output is invalid');
      writeln('***         unless the duplicates are fixed.');
      writeln

   end;
   for i := 1 to max do begin { find primes }

      h := hash(loadarr[i]); { find the entry hash }
      if ressym[h].reslab = '          ' then begin { prime }

         ressym[h].reslab := loadarr[i]; { place }
         loadarr[i] := '          ' { clear old entry }

      end

   end;
   for i := 1 to max do begin { find slots for non-prime }

      if loadarr[i] <> '          ' then begin { left tover }

         h := hash(loadarr[i]); { find the entry hash }
         { find terminal entry }
         while ressym[h].reschn <> 0 do h := ressym[h].reschn;
         x := 1; { find free slot }
         while ressym[x].reslab <> '          ' do x := x + 1;
         ressym[h].reschn := x; { chain to this entry }
         ressym[x].reslab := loadarr[i]; { place entry }
         loadarr[i] := '          ' { clear that }

      end

   end;
   { find maximum label size }
   labsiz := 0; { clear maximum size }
   for i := 1 to max do begin { traverse labels }

      labc := 0; { clear this label size }
      { count label characters }
      for x := 1 to 10 do if ressym[i].reslab[x] <> ' ' then labc := labc+1;
      if labc > labsiz then labsiz := labc; { find new maximum }

   end;
   wrtdef; { write opcode definition file }
   wrtini; { write reserved table initialization }
   writeln('Function complete');

   99: { end program }

   close(labfil); { close files }
   close(deffil);
   close(inifil)

end.

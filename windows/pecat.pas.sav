{******************************************************************************
*                                                                             *
*                        PORTABLE EXECUTIVE FILE DUMPER                       *
*                                                                             *
*                            95/04 S. A. Moore                                *
*                                                                             *
* Works on Microsoft Portable Executive (PE) files, which are the common      *
* currency of Win 32 based systems. This program was tested with win95.       *
* Dumps sundry information from the file.                                     *
*                                                                             *
******************************************************************************}

program pedump(output);

uses strlib,
     extlib,
     parlib;

label 99; { abort program }

const

   hdrfix = 176;  { number of bytes in the fixed portion of the header }
   maxlab = 100;  { number of characters in label }
   maxext = 4;    { number of characters in an extention }
   maxlin  = 200; { number of characters in a text line }
   maxfil  = 100; { number of characters in a file name }

type 

   objptr = ^objrec; { pointer to object record }
   objlab = packed array [1..8] of char; { object names }
   { file object records }
   objrec = record

      name: objlab; { name of object }
      vsiz: integer; { virtual size }
      rva:  integer; { location in memory }
      psiz: integer; { physical size }
      poff: integer; { physical offset }
      prel: integer; { pointer to relocations }
      plin: integer; { pointer to line numbers }
      rels: integer; { relocation count }
      lins: integer; { line count }
      oflg: integer; { object flags }
      next: objptr   { next entry }

   end;
   labt = packed array [1..maxlab] of char; { label }
   extinx  = 1..maxext; { index for file extentions }
   extbuf  = packed array [extinx] of char; { extention }
   lininx  = 1..maxlin;  { index for text line }
   linbuf  = packed array [lininx] of char; { a text line }
   filinx  = 1..maxfil; { index for file names }
   filnam  = packed array [filinx] of char; { a file name }
   { errors }
   errcod = (efilovf,  { filename too long }
             einvfil,  { write('Invalid filename }
             einvcmd,  { command line syntax invalid }
             einvffm,  { invalid PE file format }
             edsymtl,  { DLL symbol too long }
             einvsyt,  { invalid symbols table }
             efilnf);  { input file not found }

var 

   exefil:  bytfil; { .exe file to read from }
   objects: integer; { number of objects in file }
   hdrsiz:  integer; { size of header }
   objlst:  objptr; { object directory list }
   objend:  objptr; { end of object list }
   import:  integer; { inport table RVA }
   export:  integer; { export table RVA }
   cmdlin:  linbuf; { command line buffer }
   cmdptr:  lininx; { command line index }
   cmdlen:  lininx; { command line length }
   dmpfil:  filnam; { file to dump }
   p, n, e: filnam; { file components }
   dmphdr:  filnam; { dump file header }
   fopnsrc: boolean; { source file is open }
   stbobj:  objptr; { GCC symbols table object }
   stsobj:  objptr; { GCC symbols list object }
   cofsym:  integer; { location of COFF symbols }
   cofnum:  integer; { number of COFF symbols }
   valfch:  chrset;  { valid file characters }
   cmdhan:  parhan;  { handle for command parsing }
   err:     boolean; { error holder }
   w:       integer;
   i:       integer;
   b:       byte;

{******************************************************************************

Process error

Prints the given error code, and aborts the program.

******************************************************************************}

procedure error(e: errcod);

begin

   write('*** ');
   case e of { error }

      efilovf: write('Filename too long');
      einvfil: write('Invalid filename');
      einvcmd: write('Command line invalid');
      einvffm: write('Invalid input PE file format or not 32 bit PE');
      edsymtl: write('DLL symbol too long');
      efilnf:  write('Input file not found');
      einvsyt: write('Invalid symbol file format');

   end;
   writeln; { terminate line }
   goto 99 { terminate program }

end;

{******************************************************************************

Read a 16 bit word from file

******************************************************************************}

procedure readwrd(var f: bytfil; var w: integer);

var b1, b2: byte;
    i1, i2: integer;

begin

   read(f, b1); { get low byte }
   read(f, b2); { get high byte }
   i1 := b1; { expand the value }
   i2 := b2;
   w := i2*256+i1 { place result }

end;
    
{******************************************************************************

Read a 32 bit word from file

******************************************************************************}

procedure readdwd(var f: bytfil; var w: integer);

var b1, b2, b3, b4: byte;
    i1, i2, i3, i4: integer;

begin

   read(f, b1); { get low byte }
   read(f, b2); { get mid low byte }
   read(f, b3); { get mid high byte }
   read(f, b4); { get high byte }
   i1 := b1; { expand the value }
   i2 := b2;
   i3 := b3;
   i4 := b4;
   w := i4*16777216+i3*65536+i2*256+i1 { place result }

end;

{******************************************************************************

Print hex

******************************************************************************}

procedure prthex(f: byte; w: integer);
 
var buff: array [1..10] of char; { buffer for number in ascii }
    i:    integer; { index for same }
    t:    integer; { holding }
 
begin

   { set sign of number and convert }
   if w < 0 then begin

      w := w+1+maxint; { convert number to 31 bit unsigned }
      t := w div $10000000 + 8; { extract high digit }
      writeh(output, t); { ouput that }
	   w := w mod $10000000; { remove that digit }
      f := 7 { force field to full }     

   end;
   hexsp(buff, w); { convert the integer }
   for i := 1 to f-lenp(buff) do write('0'); { pad with leading zeros }
   writesp(output, buff) { output number }

end;

{******************************************************************************

Load the object table

******************************************************************************}

procedure lodobj(objects: integer);

var i: integer;
    b: byte;
    x: integer;
    op: objptr; { pointer for object list }

begin

   for i := 1 to objects do begin { objects }
    
      new(op); { create new object entry }
      op^.next := nil; { clear next }
      if objlst = nil then begin { insert as first }
     
         objlst := op; { set as first entry }
         objend := op { set as last entry }
   
      end else begin { insert as last }
   
         objend^.next := op; { link to last }
         objend := op { set new last }
   
      end;   
      for x := 1 to 8 do begin { read object name }

         read(exefil, b); { get character }
         op^.name[x] := chr(b and $7f) { place character }

      end;
      readdwd(exefil, op^.vsiz); { get virtual size }
      readdwd(exefil, op^.rva); { get RVA }
      readdwd(exefil, op^.psiz); { get physical size }
      readdwd(exefil, op^.poff); { get physical offset }
      readdwd(exefil, op^.prel); { get relocations }
      readdwd(exefil, op^.plin); { get lines }
      readwrd(exefil, op^.rels); { get reloc count }
      readwrd(exefil, op^.lins); { get line count }
      readdwd(exefil, op^.oflg) { get object flags }

   end

end;

{******************************************************************************

Find object by RVA

******************************************************************************}

function fndrva(rva: integer): objptr;

var op, fp: objptr; { pointers for objects }

begin

   { find object corresponding to the import section }
   fp := nil; { clear target object }
   op := objlst; { index top of object list }
   while op <> nil do begin

      if (rva >= op^.rva) and (rva < (op^.rva+op^.vsiz)) then
         fp := op; { found it, set }
      op := op^.next { next entry }

   end;
   if fp = nil then error(einvffm); { does not link up to an object, bad }
   fndrva := fp { return result }

end;

{*******************************************************************************

Find physical address from RVA

Given an RVA, finds the object that the RVA exists within, then finds the net
offset address in the file from that.

*******************************************************************************}

function fndoff(rva: integer): integer;

var op: objptr; { pointer for object }

begin

   op := fndrva(rva); { find the object containing the RVA }
   
   fndoff := rva-(op^.rva-op^.poff)

end;

{*******************************************************************************

Print the export table

*******************************************************************************}

procedure prtexp;

type expptr = ^expnam; { export name entry pointer }
     expnam = record

        nam:  labt;    { symbol name }
        nrva: integer; { RVA for symbol name (used while loading) }
        ordn: integer; { ordinal number }
        rva:  integer; { rva }
        next: expptr   { next entry }

     end;

var dir:    record { export header }

       flags: integer; { export flags }
       tdat:  integer; { date/time }
       rev:   integer; { user version }
       nrva:  integer; { name RVA }
       bord:  integer; { ordinal base }
       eatc:  integer; { EAT count }
       namc:  integer; { name count }
       atrva: integer; { address table RVA }
       ntrva: integer; { name table RVA }
       otrva: integer; { ordinal table RVA }
       slist: expptr   { export symbol list }

    end;
    sp:     expptr; { export symbol pointer }
    sc:     integer; { symbol count }
    ords:   array [1..1000] of integer; { ordinal holding }
    rvas:   array [1..1000] of integer; { name rvas }
    oi:     0..1000; { index for ordinal array }
    maxlen: 0..maxlab;
    li:     1..maxlab;
    i:      integer;

function fndord(o: integer) { ordinal to find }
               : integer;   { index of ordinal found }

var i: 1..1000; { index for ordinals }
    r: 0..1000; { index for found ordinal }

begin

   r := 0; { set not found }
   { find ordinal and set status }
   for i := 1 to dir.namc do if ords[i] = o then r := i;
   fndord := r { set status }

end;
  
begin

   position(exefil, fndoff(export)+1); { position to export directory }
   { load export header }
   readdwd(exefil, dir.flags); { get flags }
   readdwd(exefil, dir.tdat); { get date/time }
   readdwd(exefil, dir.rev); { get user version }
   readdwd(exefil, dir.nrva); { get name RVA }
   readdwd(exefil, dir.bord); { get ordinal base }
   readdwd(exefil, dir.eatc); { get EAT count }
   readdwd(exefil, dir.namc); { get name count }
   readdwd(exefil, dir.atrva); { get address table RVA }
   readdwd(exefil, dir.ntrva); { get name table RVA }
   readdwd(exefil, dir.otrva); { get ordinal table RVA }
   dir.slist := nil; { clear symbols list }
   { create export symbols, including anonymous }
   for sc := 1 to dir.eatc do begin

      new(sp); { get a symbol entry }
      { clear label }
      for li := 1 to maxlab do sp^.nam[li] := ' ';
      sp^.next := dir.slist; { insert to list }
      dir.slist := sp;
      sp^.rva := 0 { clear rva }

   end;
   { load ordinals }
   position(exefil, fndoff(dir.otrva)+1);
   for i := 1 to dir.namc do readwrd(exefil, ords[i]);
   { load symbol rvas }
   position(exefil, fndoff(dir.ntrva)+1);
   for i := 1 to dir.namc do readdwd(exefil, rvas[i]);
   { assign ordinals to symbols }
   sp := dir.slist; { index 1st symbol }
   for i := 1 to dir.eatc do begin

      sp^.ordn := i-1; { place ordinal number }
      oi := fndord(i-1); { find corresponding ordinal }
      if oi <> 0 then sp^.nrva := rvas[oi];
      sp := sp^.next { next symbol }

   end;
   { load symbols }
   maxlen := 0; { clear maximum length }
   sp := dir.slist; { index 1st symbol }
   for sc := 1 to dir.eatc do begin { read symbols }

      if sp = nil then error(einvffm);
      if sp^.nrva <> 0 then begin { name exists }

         position(exefil, fndoff(sp^.nrva)+1); { seek to name }
         for i := 1 to maxlab do sp^.nam[i] := ' '; { clear name }
         i := 1; { set 1st label character }
         repeat { get next symbol character }

            read(exefil, b); { get a character }
            if b <> 0 then begin { symbol character }

               if i > maxlab then error(edsymtl); { overflow }
               sp^.nam[i] := chr(b); { place character }
               i := i+1 { next character }

            end

         until b = 0; { until end of string } 
         if i > maxlen then maxlen := i { set new max }

      end;
      sp := sp^.next { next symbol entry }

   end;
   { load export addresses }
   position(exefil, fndoff(dir.atrva)+1);
   sp := dir.slist; { index 1st symbol }
   for i := 1 to dir.eatc do begin { read addresses }

      if sp = nil then error(einvffm);
      readdwd(exefil, sp^.rva); { get the RVA }
      sp := sp^.next { next symbol }

   end;
   sp := dir.slist; { index top symbol }
   while sp <> nil do begin { print symbols }

      writesp(output, dmphdr); { print the header }
      write(' ');
      writesp(output, sp^.nam); { print name }
      writeln; { next line }
      sp := sp^.next { next symbol }

   end
   
end;

begin

   objlst := nil; { clear object list }
   objend := nil; { set no end }
   fopnsrc := false; { set source file not open }
   { open command line and get source file }
   openpar(cmdhan); { open parser }
   openfil(cmdhan, '_command', 250); { open command line level }
   filchr(valfch); { get the filename valid characters }
   parfil(cmdhan, dmpfil, false, err); { get a file }
   skpspc(cmdhan); { skip spaces }
   if not endlin(cmdhan) then error(einvcmd); { invalid command line }
   brknamp(dmpfil, p, n, e); {break down filename }
   copyp(dmphdr, n); { place dump header }
   if lenp(e) > 0 then begin { extention supplied }

      if not exists(dmpfil) then error(efilnf)

   end else begin { fit extentions }

      copyp(e, 'exe'); { try .exe extention }
      maknamp(dmpfil, p, n, e);
      if not exists(dmpfil) then begin { try .dll extention }

         copyp(e, 'dll'); { try .exe extention }
         maknamp(dmpfil, p, n, e);
         if not exists(dmpfil) then error(efilnf)

      end

   end;
   assign(exefil, dmpfil); { open the dump file }
   reset(exefil);
   fopnsrc := true; { set source file is open }
   readwrd(exefil, w);
   if w <> $5a4d then error(einvffm); { must be 'MZ' (.exe magic number) }
   for i := 1 to (15+4+10)*2 do read(exefil, b); { index new .exe header offset }
   readdwd(exefil, w); { get offset }
   position(exefil, w+1); { go to it }
   readdwd(exefil, w); { check 'PE<0><0>' signiture }
   if w <> $00004550 then error(einvffm); { invalid file format }
   writeln; { space off }
   readwrd(exefil, w); { get the machine type }
   readwrd(exefil, objects); { get the number of objects }
   readdwd(exefil, w); { date/time }
   readdwd(exefil, cofsym); { symbols pointer }
   readdwd(exefil, cofnum); { symbols count }
   readwrd(exefil, hdrsiz); { get NT header size }
   readwrd(exefil, w); { get flags }
   readwrd(exefil, w); { get nt header magic }
   readwrd(exefil, w); { get DB ver }
   readdwd(exefil, w); { get size of code }
   readdwd(exefil, w); { get size of initalized data }
   readdwd(exefil, w); { get size of uninitalized data }
   readdwd(exefil, w); { get entry point }
   readdwd(exefil, w); { get base of code }
   readdwd(exefil, w); { get base of data }
   readdwd(exefil, w); { get base }
   readdwd(exefil, w); { get object align }
   readdwd(exefil, w); { get file align }
   readdwd(exefil, w); { get OS ver }
   readdwd(exefil, w); { get user ver }
   readdwd(exefil, w); { get subsystem ver }
   readdwd(exefil, w); { res }
   readdwd(exefil, w); { image size }
   readdwd(exefil, w); { header size }
   readdwd(exefil, w); { file checksum }
   readwrd(exefil, w); { subsystem type }
   readwrd(exefil, w); { DLL flags }
   readdwd(exefil, w); { stack reserve size }
   readdwd(exefil, w); { stack commit size }
   readdwd(exefil, w); { heap reserve size }
   readdwd(exefil, w); { heap commit size }
   readdwd(exefil, w); { get loader flags }
   readdwd(exefil, w); { interesting va/sizes }
   readdwd(exefil, export); { export table RVA }
   readdwd(exefil, w); { total export data size }
   readdwd(exefil, import); { import table RVA }
   for i := 1 to 17 do readdwd(exefil, w); { skip }
   { skip the remaining bytes in the header }
   for i := 1 to hdrsiz-hdrfix do read(exefil, b);
   lodobj(objects); { load the object directory }
   if export <> 0 then prtexp; { print the export table }
   
   99:; { abort program }

   if fopnsrc then close(exefil) { close input file }

end.

unit link;

interface

uses {$U basicio.j} basicio, { system I/O file }
     {$U lndef.j}   lndef,   { global definitions file }
     {$U common.j}  common,  { global variables file }
     {$U utl.j}     utl;     { utilities file }

procedure dumpsym; { dump symbols table }
procedure dumprld; { dump rld table }
procedure origin; { set program origin }
procedure prcobj; { process object file }
procedure outsym; { output symbol file }
procedure report; { generate undefineds report }
procedure rdsyms; { read symbols file }
procedure apnsym; { append new symbols deck }
procedure mrgsym; { merge old and new symbols decks }
procedure reduce; { reduce symbols operations }
procedure srtrld; { sort rld table }
procedure listsym; { list symbols }
procedure srtalp; { sort symbols for alphabetical order }
procedure srtval; { sort symbols for value order }
procedure listxrf; { perform cross reference listing }
procedure fndmax; { find maximum symbol length }
procedure listmod; { perform module parameter listing }
procedure srcmax; { find maximum filenames length }

implementation

{******************************************************************************

Print entry number for symbol

Given a symbol, prints the entry number for it, or the count from start of
the symbol table. A diagnostic.

******************************************************************************}

procedure prtsyn(sym: symptr);

var sc: integer; { symbol count }
    sp: symptr;  { symbols pointer }

begin

   if sym = nil then writeln('nil') else begin

      sp := symtab; { index top of table }
      sc := 1; { set 1st entry number }
      while (sp <> sym) and (sp <> nil) do begin { traverse }
   
         sc := sc+1; { count entries }
         sp := sp^.next { link next entry }
   
      end;
      if sp <> nil then write(sc:1) { print number }
      else write('???')

   end

end;

{******************************************************************************

Dump contents of current rld table

A diagnostic, prints each entry in the current rld table, one per line,
in fairly memonic fashion.

******************************************************************************}

procedure dumprld;

var rp: rldptr; { pointer for rlds }
    rc: integer; { rld counter }

begin

   writeln('RLD table');
   writeln;
   rp := rldtab; { index top of table }
   rc := 1; { set 1st entry }
   while rp <> nil do begin { traverse }

      write(rc:1, ': '); { print entry number }
      write(' it[');
      case rp^.im of { insertion mode }

         imnorm: write('norm');  { normal }
         imsgof: write('off');   { signed offset }
         imnsof: write('ns off') { non-standard offset }

      end;
      write('] flags[');
      if rp^.big then write('big '); { output big endian flag }
      if rp^.adf then write('add '); { output value is address flag }
      if rp^.vrs then write('var '); { output value is variable address flag }
      if rp^.def then write('def '); { output defined flag }
      write('] bits[', rp^.str:1, ':', rp^.len:1, '] val[', rp^.val, ']');
      write(' addr[');
      prthex(digits, rp^.add); { print address of insertion }
      write(']');
      if rp^.inssym <> nil then begin { insert symbol exists }

         write(' insym[');
         prtsyn(rp^.inssym);
         write(']')

      end;
      writeln; { terminate line }
      rp := rp^.next; { link next rld }
      rc := rc+1 { count entries }

   end;
   writeln { space off }

end; 

{******************************************************************************

Dump contents of current symbol table

A diagnostic, prints each entry in the current symbol table, one per line,
in fairly memonic fashion.

******************************************************************************}

procedure dumpsym;

var sp: symptr; { pointer for symbols table }
    sc: integer; { symbols counter }

begin

   writeln('Symbol table');
   writeln;
   sc := 1; { set 1st symbol number }
   sp := symtab; { index top of symbol table }
   while sp <> nil do begin { traverse table }

      write(sc:1, ': opr['); { print symbol number }
      case sp^.opr of { operation }

         onop: write('nop');
         oadd: write('add');
         osub: write('sub');
         omult: write('mult');
         odiv: write('div');
         omod: write('mod');
         oshl: write('shl');
         oshr: write('shr');
         oand: write('and');
         oor: write('or');
         oxor: write('xor');
         onot: write('not');
         oneg: write('neg')

      end;
      write('] lab['); { space off }
      prtlab(sp^.lab); { print symbol label }
      write('] flags['); { space off }
      if sp^.def then write('def '); { print defined flag }
      if sp^.add then write('add '); { print address flag }
      if sp^.gbl then write('gbl '); { print global flag }
      if sp^.ext then write('ext '); { print external flag }
      if sp^.vrs then write('var '); { print variable flag }
      write('] val[', sp^.val:1, ']');
      if sp^.lft <> nil then begin { left branch exists }

         write(' left[');
         prtsyn(sp^.lft); { print left entry number }
         write(']')

      end;
      if sp^.rgt <> nil then begin { left branch exists }

         write(' right[');
         prtsyn(sp^.rgt); { print right entry number }
         write(']')

      end;
      writeln; { terminate line }
      sp := sp^.next; { link next entry }
      sc := sc+1 { count entries }

   end;
   writeln { space off }

end;

{******************************************************************************

Get symbol entry

Gets a symbol entry either from the free list, or creates one.

******************************************************************************}

procedure getsym(var p: symptr);

var i: labinx;

begin

   if fresym <> nil then begin { get existing entry }

      p := fresym; { index symbol }
      fresym := fresym^.next { gap list }

   end else new(p);
   p^.opr  := onop; { clear fields }
   for i := 1 to maxlab do p^.lab[i] := ' ';
   p^.def  := false;
   p^.add  := false;
   p^.gbl  := false;
   p^.ext  := false;
   p^.vrs  := false;
   p^.val  := 0;
   p^.lft  := nil;
   p^.rgt  := nil;
   p^.err  := false;
   p^.next := nil

end;

{******************************************************************************

Put symbol entry

Places the given symbol entry on the free list.

******************************************************************************}

procedure putsym(p: symptr);

begin

   p^.next := fresym; { link to list }
   fresym := p

end;

{******************************************************************************

Get rld entry

Gets an rld entry either from the free list, or creates one.

******************************************************************************}

procedure getrld(var p: rldptr);

begin

   if frerld <> nil then begin { get existing entry }

      p := frerld; { index symbol }
      frerld := frerld^.next { gap list }

   end else new(p);
   p^.big    := false; { clear fields }
   p^.im     := imnorm;
   p^.cof    := 0;
   p^.str    := 0;
   p^.len    := 0;
   p^.add    := 0;
   p^.inssym := nil;
   p^.val    := 0;
   p^.adf    := false;
   p^.vrs    := false;
   p^.def    := false;
   p^.next   := nil

end;

{******************************************************************************

Put rld entry

Places the given rld entry on the free list.

******************************************************************************}

procedure putrld(p: rldptr);

begin

   p^.next := frerld; { link to list }
   frerld := p

end;

{******************************************************************************

Move symbol to current

Moves the given symbol entry from the saved deck to the current deck.

******************************************************************************}

procedure movsym(sym: symptr); { symbol to move }

var lp, sp: symptr; { symbol entry pointers }

begin

   { remove from saved table }
   if symsav = sym then { symbol is the root }
      symsav := symsav^.next { gap from list }
   else begin { search list }

      sp := symsav; { index top of saved symbols }
      while (sp <> sym) and (sp <> nil) do begin { traverse symbols }

         lp := sp; { set last entry }
         sp := sp^.next { link next entry }

      end;
      if sp = nil then fprterr(esysflt); { fault: was not in list }
      lp^.next := sym^.next { gap over entry }

   end;
   sym^.next := symtab; { link into current table }
   symtab := sym

end;

{******************************************************************************

Delete symbol from current

Removes the given symbol from the current, which must have no other references
to it besides just being in the list.

******************************************************************************}

procedure delsym(sym: symptr); { symbol to delete }

var lp, sp: symptr; { symbol entry pointers }

begin

   { remove from symbol table }
   if symtab = sym then { symbol is the root }
      symtab := symtab^.next { gap from list }
   else begin { search list }

      sp := symtab; { index top of symbols }
      while (sp <> sym) and (sp <> nil) do begin { traverse symbols }

         lp := sp; { set last entry }
         sp := sp^.next { link next entry }

      end;
      if sp = nil then fprterr(esysflt); { fault: was not in list }
      lp^.next := sym^.next { gap over entry }

   end

end;

{******************************************************************************

Merge current and old symbols and rlds

The old symbols deck is linked in atop the new symbols deck, and the old
rlds deck is linked atop the old symbols deck.

******************************************************************************}

procedure mrgsym;

var sp: symptr; { symbols pointer }
    rp: rldptr; { rld pointer }

begin

   { merge symbols tables }
   if symtab = nil then symtab := symsav { current empty, just set to old }
   else begin { find end of current list }

      sp := symtab; { index 1st symbol }
      while sp^.next <> nil do sp := sp^.next; { find end entry }
      sp^.next := symsav { link new to old list }

   end;
   { merge rld tables }
   if rldtab = nil then rldtab := rldsav { current empty, just set to old }
   else begin { find end of current list }

      rp := rldtab; { index 1st rld }
      while rp^.next <> nil do rp := rp^.next; { find end entry }
      rp^.next := rldsav { link new to old list }

   end;

end;

{******************************************************************************

Input variger

Inputs a variger to the given integer.
Varigers are of the following format:

   1. (byte) the tag byte.
   2-N. The variger value.

The tag byte values are:

   bit 7 - Low for integer number, high for float.
   bit 6 - Contains the sign of the integer. 
   bit 5 - Unused.
   bit 4 - Length of integer in bytes, 1-32, in -1 format.
   bit 3 -      ""              ""
   bit 2 -      ""              ""
   bit 1 -      ""              ""
   bit 0 -      ""              ""

The integer is converted by removing the sign bit and converting
to signed magnitude, then determining the byte size, then
outputting the tag and number.

******************************************************************************}

procedure rdvar(var f: bytfil; var n: integer); { integer to output}

var t: byte;     { tag byte }
    s: integer;  { sign }
    b: byte;     { read byte holder }

begin

   readbyt(symfil, t); { get tag byte }
   if (t and $80) <> 0 then fprterr(efltfmt); { floating point not implemented }
   if (t and $40) <> 0 then s := -1 else s := 1; { set sign of value }
   if (t and $20) <> 0 then fprterr(esymfmt); { invalid symbol file format }
   t := (t and $1f)+1; { mask byte length and adjust }
   n := 0; { clear result }
   while t <> 0 do begin { read in bytes of value }

      n := n*256; { scale up bytes for big endian format }
      readbyt(symfil, b); { get the next byte }
      n := n+b; { add in }
      t := t-1 { count bytes read }

   end;
   n := n*s { set sign of result }

end;

{******************************************************************************

Read next symbol file entry

Reads the next symbol file entry. The next object in the symbols file is read,
either a symbol entry or an rld entry. 
The object parameters are placed in the global save area, so that a
"lookahead" mechanisim is implemented.

******************************************************************************}

procedure rdnxt;

var b:   byte;    { read byte holding }
    i:   integer;

begin

   readbyt(symfil, b); { get the next object type }
   if b in [ord(obend), ord(obsym), ord(obcst), ord(obrld), ord(obcrld)] then
      case b of { object }

      0 { obend  }: nxtobj := obend;
      1 { obsym  }: nxtobj := obsym;
      2 { obcst  }: nxtobj := obcst;
      3 { obrld  }: nxtobj := obrld;
      4 { obcrld }: nxtobj := obcrld

   end else fprterr(esymfmt); { invalid file symbol format }
   if (nxtobj = obsym) or (nxtobj = obcst) then begin { symbol }

      getsym(nxtsym); { get a symbol entry }
      readbyt(symfil, b); { get the operation code }
      if b in [ord(onop), ord(oadd), ord(osub), ord(omult), ord(odiv),
               ord(omod), ord(oshl), ord(oshr), ord(oand), ord(oor),
               ord(oxor), ord(onot), ord(oneg)] then case b of { operation }

         0  { onop  }: nxtsym^.opr := onop; 
         1  { oadd  }: nxtsym^.opr := oadd; 
         2  { osub  }: nxtsym^.opr := osub;
         3  { omult }: nxtsym^.opr := omult; 
         4  { odiv  }: nxtsym^.opr := odiv; 
         5  { omod  }: nxtsym^.opr := omod; 
         6  { oshl  }: nxtsym^.opr := oshl; 
         7  { oshr  }: nxtsym^.opr := oshr; 
         8  { oand  }: nxtsym^.opr := oand; 
         9  { oor   }: nxtsym^.opr := oor; 
         10  { oxor  }: nxtsym^.opr := oxor; 
         11 { onot  }: nxtsym^.opr := onot; 
         12 { oneg  }: nxtsym^.opr := oneg

      end else fprterr(esymfmt); { invalid symbol file format }
      if nxtobj = obsym then begin { get symbol label }

         readbyt(symfil, b); { get the symbol length }
         for i := 1 to b+1 do begin { read symbol characters }

            readbyt(symfil, b); { get a symbol character }
            if not (chr(b) in ['_', 'a'..'z', 'A'..'Z', '0'..'9']) then
               fprterr(esymfmt); { invalid symbol file format }
            if i > maxlab then fprterr(esymlen); { symbol too long }
            nxtsym^.lab[i] := chr(b) { place character }

         end

      end;
      readbyt(symfil, b); { get flags byte }
      if (b and $80) <> 0 then fprterr(esymfmt); { invalid symbol file format }
      if (b and $40) <> 0 then fprterr(esymfmt); { invalid symbol file format }
      if (b and $20) <> 0 then fprterr(esymfmt); { invalid symbol file format }
      nxtsym^.vrs := (b and $10) <> 0; { set variable space flag }
      nxtsym^.ext := (b and $08) <> 0; { set external flag }
      nxtsym^.gbl := (b and $04) <> 0; { set global flag }
      nxtsym^.add := (b and $02) <> 0; { set address flag }
      nxtsym^.def := (b and $01) <> 0; { set defined flag }
      if nxtsym^.def then rdvar(symfil, nxtsym^.val) { defined, get value }

   end else if (nxtobj = obrld) or (nxtobj = obcrld) then begin { rld }

      getrld(nxtrld); { get an rld entry }
      readbyt(symfil, b); { get it tag byte }
      nxtrld^.big := (b and $80) <> 0; { set big endian flag }
      if (b and $40) <> 0 then fprterr(esymfmt); { invalid symbol format }
      if (b and $20) <> 0 then fprterr(esymfmt); { invalid symbol format }
      case (b and $18) div $08 of { insertion type }

         0: nxtrld^.im := imnorm; { normal }
         1: nxtrld^.im := imsgof; { signed offset }
         2: nxtrld^.im := imnsof  { non-standard signed offset }

      end;
      nxtrld^.str := b and $7; { set bit field start }
      readbyt(symfil, b); { get bit length }
      nxtrld^.len := b+1; { place }
      if nxtrld^.im = imnsof then begin { constant offset exists }

         readbyt(symfil, b); { get constant offset }
         nxtrld^.cof := b { place }

      end;
      rdvar(symfil, nxtrld^.add); { get address }
      if nxtobj = obcrld then begin { constant rld, value exists }

         readbyt(symfil, b); { get flag byte }
         if (b and $80) <> 0 then fprterr(esymfmt); { invalid symbol file format }
         if (b and $40) <> 0 then fprterr(esymfmt); { invalid symbol file format }
         if (b and $20) <> 0 then fprterr(esymfmt); { invalid symbol file format }
         nxtrld^.vrs := (b and $10) <> 0; { set variable space flag }
         if (b and $08) <> 0 then fprterr(esymfmt); { invalid symbol file format }
         if (b and $04) <> 0 then fprterr(esymfmt); { invalid symbol file format }
         nxtrld^.adf := (b and $02) <> 0; { set address space flag }
         nxtrld^.def := (b and $01) <> 0; { set defined flag }
         { the 'defined' flag must be set for constant rlds }
         if not nxtrld^.def then fprterr(esymfmt); { invalid symbol file format }
         rdvar(symfil, nxtrld^.val) { get value }

      end

   end { else must be end of file }

end;      

{******************************************************************************

Adjust rld entry

Adjusts an rld entry by adding the current program and variable offsets
to the address and value fields, as appropriate by the rld flags.

******************************************************************************}

procedure adjrld(rld: rldptr);

begin

   rld^.add := rld^.add+poff; { offset address }
   { if value is defined, and in address space, offset by address }
   if rld^.def then begin { value field is defined }

      if rld^.adf then { value is in address space } 
         rld^.val := rld^.val+poff { offset in program space }
      else if rld^.vrs then { value is in variable space }
         rld^.val := rld^.val+voff { offset in variable space }

   end

end;

{******************************************************************************

Adjust symbol entry

Adjusts a symbol entry by adding the current program and variable offsets
to the value field, as appropriate by the symbol flags.

******************************************************************************}

procedure adjsym(sym: symptr);

begin

   if sym^.def and (sym^.opr = onop) then begin 

      { symbol is defined and simple }
      if sym^.add then { symbol is in program space }
         sym^.val := sym^.val+poff { offset in program space }
      else if sym^.vrs then { symbol is in variable space }
         sym^.val := sym^.val+voff { offset in variable space }

   end

end;

{******************************************************************************

Adjust symbol and RLD decks

Adjusts all of the current symbol and RLD entries by the current poff and
voff parameters.

******************************************************************************}

procedure adjusts;

var sp: symptr; { pointer for symbols }
    rp: rldptr; { pointer for rlds }

begin

   sp := symtab; { index top of symbols }
   while sp <> nil do begin { traverse }

      adjsym(sp); { adjust symbol entry }
      sp := sp^.next { link next symbol }

   end;
   rp := rldtab; { index top of RLDs }
   while rp <> nil do begin { traverse }

      adjrld(rp); { adjust RLD entry }
      rp := rp^.next { link next RLD }

   end

end;

{******************************************************************************

Sort symbols for alphabetical order

Places the symbols in acending alphabetical order.
 
******************************************************************************}

procedure srtalp;

var sp, dp, lp, np: symptr; { symbols pointers }

begin

   dp := nil; { clear desination list }
   while symtab <> nil do begin { sort entry into place }

      sp := symtab; { index top entry }
      symtab := symtab^.next; { gap from original list }
      sp^.next := nil; { terminate }
      if dp = nil then dp := sp { insert at top }
      else if labltn(sp^.lab, dp^.lab) then begin { insert at top }

         sp^.next := dp; { insert into list }
         dp := sp

      end else begin { insert middle or end }

         np := dp; { index top of list }
         while not labltn(sp^.lab, np^.lab) and (np^.next <> nil) do begin { traverse }

            lp := np; { set new last }
            np := np^.next { next entry }

         end;
         if labltn(sp^.lab, np^.lab) then begin { insert before }

            sp^.next := np; { link to next }
            lp^.next := sp { link to last }

         end else np^.next := sp { insert after }

      end

   end;
   symtab := dp { place sorted list }

end;

{******************************************************************************

Sort symbols for numeric order

Places the symbols in acending numeric order.
 
******************************************************************************}

procedure srtval;

var sp, dp, lp, np: symptr; { symbols pointers }

begin

   dp := nil; { clear desination list }
   while symtab <> nil do begin { sort entry into place }

      sp := symtab; { index top entry }
      symtab := symtab^.next; { gap from original list }
      sp^.next := nil; { terminate }
      if dp = nil then dp := sp { insert at top }
      else if sp^.val < dp^.val then begin { insert at top }

         sp^.next := dp; { insert into list }
         dp := sp

      end else begin { insert middle or end }

         np := dp; { index top of list }
         while (sp^.val >= np^.val) and (np^.next <> nil) do begin { traverse }

            lp := np; { set new last }
            np := np^.next { next entry }

         end;
         if sp^.val < np^.val then begin { insert before }

            sp^.next := np; { link to next }
            lp^.next := sp { link to last }

         end else np^.next := sp { insert after }

      end

   end;
   symtab := dp { place sorted list }

end;

{******************************************************************************

Find maximum length of symbols

Finds the maximum length of any symbol in the symbol table. This is used to
format tables properly.
 
******************************************************************************}

procedure fndmax;

var sp: symptr;    { pointer for symbols }
    i:  labinx;    { index for labels }
    c:  0..maxlab; { label length counter }

begin

   symlen := 0; { clear maximum length of symbols }
   sp := symtab; { index top symbol }
   while sp <> nil do begin { traverse }

      c := 0; { clear label count }
      { count characters in label }
      for i := 1 to maxlab do if sp^.lab[i] <> ' ' then c := c+1;
      if c > symlen then symlen := c; { find max }
      sp := sp^.next { next symbol }

   end

end;

{******************************************************************************

Find maximum length of filenames

Finds the maximum length of any filename in the source list. This is used to
format tables properly.
 
******************************************************************************}

procedure srcmax;

var fp: filptr;    { pointer for symbols }
    i:  labinx;    { index for labels }
    c:  0..maxfil; { filename length counter }

begin

   srclen := 0; { clear maximum length of source files }
   fp := srclst; { index top filename }
   while fp <> nil do begin { traverse }

      addext(fp^.nam, '    ', true); { clear extention }
      c := 0; { clear label count }
      { count characters in label }
      for i := 1 to maxfil do if fp^.nam[i] <> ' ' then c := c+1;
      if c > srclen then srclen := c; { find max }
      fp := fp^.next { next symbol }

   end

end;

{******************************************************************************

Report undefined symbols

Searches the current symbols table for undefined entries, and if found,
produces a report on all such entries. The report listing outputs up to
7 symbols on a line. At this version, we are dependent on having only 10
character internal symbols in LN.
 
******************************************************************************}

procedure report;

var sp:     symptr;  { pointer for symbols }
    first:  boolean; { first undefined print flag }
    symcnt: integer; { count of symbols output on line }
    i:      labinx;  { index for labels }

begin

   first := true; { set first undefined symbol }
   symcnt := 0; { clear output count }
   sp := symtab; { index top symbol }
   while sp <> nil do begin { traverse }

      if (sp^.lab[1] <> ' ') and not sp^.def then begin { symbol undefined }

         if first then begin { write header }

            writeln; { space off }
            writeln('Undefined symbols:'); 
            writeln 

         end;
         for i := 1 to symlen do write(sp^.lab[i]); { output symbol }
         write(' '); { space off }
         symcnt := symcnt+1; { count symbols output on line }
         if symcnt = lstlen div (symlen+1) then begin { line overflow }

            writeln; { terminate line }
            symcnt := 0 { clear counter }

         end;
         first := false { set not first undefined }

      end;
      sp := sp^.next { link next symbol }

   end;
   if symcnt <> 0 then writeln { terminate unfinished line }

end;

{******************************************************************************

List symbols

Lists symbols, values and status in multicollumn format.
 
******************************************************************************}

procedure listsym;

var sp:     symptr;  { pointer for symbols }
    symcnt: integer; { count of symbols output on line }
    i:      labinx;  { index for labels }

begin

   writeln; { space off }
   symcnt := 0; { clear output count }
   sp := symtab; { index top symbol }
   while sp <> nil do begin { traverse }

      if (sp^.lab[1] <> ' ') then begin { symbol entry } 

         for i := 1 to symlen do write(sp^.lab[i]); { output symbol }
         write(' '); { space off }
         prthex(digits, sp^.val); { print symbol value }
         write(' '); { space off }
         if sp^.add then write('a') else write('.'); { write address status }
         if sp^.vrs then write('v') else write('.'); { write variable status }
         if sp^.gbl then write('g') else if sp^.ext then write('e') else 
            write('.'); { write variable status }
         if sp^.def then write('d') else write('.'); { write defined status }
         if sp^.opr <> onop then 
            write('c') else write('.'); { write complex/simplestatus }
         write('  ');
         symcnt := symcnt+1; { count symbols output on line }
         if symcnt = lstlen div (digits+symlen+9) then begin { line overflow }

            writeln; { terminate line }
            symcnt := 0 { clear counter }

         end;

      end;
      sp := sp^.next { link next symbol }

   end;
   if symcnt <> 0 then writeln { terminate unfinished line }

end;

{******************************************************************************

List cross reference

Lists symbols, one per line, followed by a list of references to that symbol.
 
******************************************************************************}

procedure listxrf;

var sp:     symptr;  { pointer for symbols }
    i:      labinx;  { index for labels }
    rp:     rldptr;  { pointer for rlds }
    adrcnt: integer; { count of addresses output on line }
    ix:     integer; { general index }

begin

   writeln; { space off }
   writeln('Symbols cross reference listing:');
   writeln;
   sp := symtab; { index top symbol }
   while sp <> nil do begin { traverse }

      if (sp^.lab[1] <> ' ') then begin { symbol entry } 

         for i := 1 to symlen do write(sp^.lab[i]); { output symbol }
         write(' '); { space off }
         prthex(digits, sp^.val); { print symbol value }
         write(' '); { space off }
         if sp^.add then write('a') else write('.'); { write address status }
         if sp^.vrs then write('v') else write('.'); { write variable status }
         if sp^.gbl then write('g') else if sp^.ext then write('e') else 
            write('.'); { write variable status }
         if sp^.def then write('d') else write('.'); { write defined status }
         if sp^.opr <> onop then 
            write('c') else write('.'); { write complex/simplestatus }
         write('  ');
         { search for references to the symbol }
         rp := rldtab; { index top of rld table }
         adrcnt := 0; { set no entries ouput }
         while rp <> nil do begin { traverse }
  
            if rp^.inssym = sp then begin { found a reference }
        
               if symlen+digits+9+((digits+10)*(adrcnt+1)) > lstlen then begin

                  { line would overflow }
                  writeln; { next line }
                  { space over symbol area }
                  for ix := 1 to symlen+digits+9 do write(' ');
                  adrcnt := 0 { set no entries on line }

               end;
               prthex(digits, rp^.add); { print address }
               write(' '); { space off }
               { write endian status }
               if rp^.big then write('b') else write('l');
               { print bit specification }
               write(':', rp^.str:1, ':');
               write(rp^.len div 100); { print length in digits }
               write(rp^.len div 10 mod 10);
               write(rp^.len mod 10);
               write('  '); { space off }
               adrcnt := adrcnt+1 { count entries output }

            end;
            rp := rp^.next { next rld }

         end;
         writeln { terminate line }

      end;
      sp := sp^.next { link next symbol }

   end

end;

{******************************************************************************

List module parameters

Lists all of the input files, their base addresses, and their lengths.
 
******************************************************************************}

procedure listmod;

var fp:    filptr;  { pointer for source file entries }
    pbase: integer; { base program address of modules }
    vbase: integer; { base variable address of modules }
    i:     filinx;  { index for filenames }
    ix:    integer; { general index }

begin

   writeln; { space off }
   writeln('Module parameter listing:');
   writeln;
   fp := srclst; { index top of source list }
   pbase := poff; { set 1st program base }
   vbase := voff; { set 1st variable base }
   while fp <> nil do begin { list modules }

      for i := 1 to srclen do write(fp^.nam[i]); { output filename }
      write(' '); { space off }
      { write input/output status of file }
      if not fsupp and (fp = srclst) then write('o') else write('i');
      write(' '); { space off }
      prthex(digits, pbase); { output base program address }
      write('-'); { space off }
      if fp^.plen <> 0 then { section has length }
         prthex(digits, pbase+fp^.plen-1) { output end program address }
      else for ix := 1 to digits do write('*'); 
      write(' '); { space off }
      prthex(digits, fp^.plen); { output module program length }
      write(' '); { space off }
      prthex(digits, vbase); { output base variable address }
      write('-'); { space off }
      if fp^.vlen <> 0 then { section has length }
         prthex(digits, vbase+fp^.vlen-1) { output end variable address }
      else for ix := 1 to digits do write('*'); 
      write(' '); { space off }
      prthex(digits, fp^.vlen); { output module variable length }
      writeln;
      if fsupp or (fp <> srclst) then begin { not output file }

         pbase := pbase+fp^.plen; { find next module program base }
         vbase := vbase+fp^.vlen  { find next module variable base }

      end;
      fp := fp^.next { next file entry }

   end

end;

{******************************************************************************

Output object value
 
The given unsigned integer is output to the object file.
The number of bytes occupied by the output value can be specified, as well as 
the big/little endian structure of the output.
If the length specified is greater than the size of an integer, padding sign 
extention bytes will be used to create an effective output of that size.
This routine is dependent on integer being 32 bits, and uses equivalence of 
"packed array [1..4] of byte" to integer to extract the value of an integer.
 
******************************************************************************}

procedure outval(val: integer;  { object integer to output }
                 len: integer;  { number of bytes to occupy }
                 big: boolean); { big endian format }

var i: integer; { counter }
    c: record case boolean of { convertion }

          false: (a: packed array [1..4] of byte);
          true:  (b: integer)

       end;
    s: integer; { sign holder }

begin

   if val < 0 then s := 255 else s := 0; { set sign extention byte }
   c.b := val; { convert integer to bytes }
   if big then begin { big endian }

      { pad > 32 bits }
      while len > 4 do begin wrtbyt(objout, s); len := len-1 end;
      for i := len downto 1 do { output bytes }
         wrtbyt(objout, c.a[i]) { output byte }

   end else begin { little endian }

      { output bytes to maximum of 4 }
      if len > 4 then for i := 1 to 4 do wrtbyt(objout, c.a[i]) { output byte }
      else for i := 1 to len do wrtbyt(objout, c.a[i]); { output byte }
      { pad > 32 bits }
      while len > 4 do begin wrtbyt(objout, s); len := len-1 end

   end

end;

{******************************************************************************

Output composite bit field

Outputs a value as a composite bit field. Given the inserted value, the backing 
value, and the start and length of bits to be inserted, a series of bytes is 
created with the insertion value imbedded.
Note: dependant on being able to use 'and', 'or' and 'not' on integers.

******************************************************************************}

procedure outbit(val: integer;  { object integer to output }
                 bak: integer;  { backing value }
                 big: boolean;  { big endian format }
                 str: integer;  { start of insertion }
                 len: integer); { number of bits to occupy }

var mask: integer;
    t:    integer; { holding }

begin

   if (str = 0) and ((len mod 8) = 0) then
      { its just an ordinay bytewise insertion, in which case the
        backing is not used }
      outval(val, len div 8, big)
   else begin { bitwise insertion }

      { form bitmask }
      mask := 1;
      t := len-1;
      while t <> 0 do begin mask := mask*2+1; t := t-1 end;
      { shift up to proper bit position }
      t := str;
      while t <> 0 do begin 

         val := val*2; { shift value }
         mask := mask*2; { shift mask }
         t := t-1 { count }

      end;
      { assemble output value }
      val := (bak and not mask) or (val and mask);       
      t := (len+str) div 8; { find total byte length }
      if ((len+str) mod 8) <> 0 then t := t + 1; { round up }
      outval(val, t, big) { and output final value }

   end

end;

{******************************************************************************

Input backing value

Inputs a backing value from the input object file. This is a byte constructed 
word value that has enough bytes to cover the given byte count, and has the 
same endian mode.
Note that it is taken on trust that the number of bytes requested exists before
the eof.

******************************************************************************}

procedure inpbak(var bak: integer;  { returns backing value }
                     big: boolean;  { big endian format }
                     siz: integer); { size of value in bytes }

var b: byte;    { input byte holder }
    p: integer; { power holder }

begin

   bak := 0; { clear backing value }
   if big then while siz <> 0 do begin { read big endian }

      readbyt(objinp, b); { get a byte }
      bak := bak*256+b; { scale backing value and add }
      siz := siz-1 { count bytes }
      
   end else begin { little endian }

      p := 1; { set first power }
      while siz <> 0 do begin { read little endian }
  
         readbyt(objinp, b); { get a byte }
         bak := bak+b*p; { scale and add }
         siz := siz-1 { count bytes }

      end

   end

end;

{***************************************************************

Output variger

Outputs the given integer to the byte file as a variger.
Varigers are of the following format:

   1. (byte) the tag byte.
   2-N. The variger value.

The tag byte values are:

   bit 7 - Low for integer number, high for float.
   bit 6 - Contains the sign of the integer. 
   bit 5 - Unused.
   bit 4 - Length of integer in bytes, 1-32, in -1 format.
   bit 3 -      ""              ""
   bit 2 -      ""              ""
   bit 1 -      ""              ""
   bit 0 -      ""              ""

The integer is converted by removing the sign bit and converting
to signed magnitude, then determining the byte size, then
outputting the tag and number.

***************************************************************}

procedure wrtvar(var f: bytfil; n: integer); { integer to output}

var t: integer; { tag byte }
    p: integer; { power holder }
    i: integer; { counter }

begin

   { handle 0 as special case }
   if n = 0 then begin wrtbyt(f, 0); wrtbyt(f, 0) end else begin

      { value is non-zero }
      t := bytes-1; { initalize tag field to max bytes }
      if n < 0 then begin { remove sign and convert to signed magnitude }
      
         t := t + $40; { place sign in tag }
         n := abs(n) { find absolute value of integer }
      
      end;
      p := toppow; { get top power }
      { find 1st non-zero digit in integer }
      while (n div p) = 0 do begin p := p div 256; t := t - 1 end;
      wrtbyt(f, t); { output finalized tagfield }
      while p <> 0 do begin { output bytes }
      
         wrtbyt(f, n div p); { output that byte }
         n := n mod p; { remove the byte }
         p := p div 256 { next lower power }      
      
      end

   end

end;

{***************************************************************
 
Output IT field

Outputs the it field, of the following format:

     ------------------
     | IT | LEN | OFF |
     ------------------

     IT is the IT flag byte

     LEN is the bit length of insertion -1

     OFF is the PC offset constant

Definition of the IT flag byte:

     bit
     7 - Low for "big endian" format insertion, high for 
         "little endian".
     6 - Low for normal insertion, high for "signed offset" 
         insertion.
     5 - Constant offset flag.
     4 - Unused
     3 - Unused
     2 - Starting bit offset (0-7)
     1 -      ""          ""
     0 -      ""          ""
 
Note that the offset field will only be present if the constant
offset flag is set.

***************************************************************}

procedure outit(r: rldptr); { rld to output it for }

var t: byte; { holding }

begin

   t := 0; { clear flag byte }
   if r^.big then t := t + $80; { place big endian flag }
   t := t+ord(r^.im)*$08; { place insertion type }
   t := t + r^.str; { place bit offset }
   wrtbyt(symfil, t); { output insertion flags }
   wrtbyt(symfil, r^.len-1); { output bit length }
   { output constant offset if required }
   if r^.cof <> 0 then wrtbyt(symfil, r^.cof)

end;

{******************************************************************************

Output basic rld entry

Outputs a symbol entry to the symbols file.

******************************************************************************}

procedure wrnrld(rld: rldptr); { rld to write }

var b: byte; { output byte holder }

begin

   if rld^.def then wrtbyt(symfil, ord(obcrld)) { type constant rld }
   else wrtbyt(symfil, ord(obrld)); { type general rld }
   outit(rld); { output IT field }   
   wrtvar(symfil, rld^.add); { output address }
   if rld^.def then begin { constant rld }

      b := 1; { set defined flag }
      if rld^.vrs then b := b+$10; { set variable space flag }
      if rld^.adf then b := b+$02; { set address space flag }
      wrtbyt(symfil, b); { output flag byte }
      wrtvar(symfil, rld^.val) { output value }

   end

end;

{******************************************************************************

Output basic symbol entry

Outputs a symbol entry to the symbols file.

******************************************************************************}
 
procedure wrnsym(sym: symptr); { symbol to write }

var i: labinx;    { index for label }
    l: 0..maxlab; { length of label }
    b: byte;      { output byte holder }

begin

   if sym^.lab[1] <> ' ' then wrtbyt(symfil, ord(obsym)) { type symbol }
   else wrtbyt(symfil, ord(obcst)); { type constant }
   wrtbyt(symfil, ord(sym^.opr)); { output operation }
   if sym^.lab[1] <> ' ' then begin { symbol }

      l := 0; { clear label length }
      { count label characters }
      for i := 1 to maxlab do if sym^.lab[i] <> ' ' then l := l+1;
      wrtbyt(symfil, l-1); { output label length }
      { output label characters }
      for i := 1 to l do wrtbyt(symfil, ord(sym^.lab[i]))

   end;
   b := 0; { clear flags byte }
   if sym^.vrs then b := b+$10; { set variable space flag }
   if sym^.ext then b := b+$08; { set external flag }
   if sym^.gbl then b := b+$04; { set global flag }
   if sym^.add then b := b+$02; { set address space flag }
   if sym^.def then b := b+$01; { set defined flag }
   wrtbyt(symfil, b); { output flags byte }
   if sym^.def then { symbol is defined }
      wrtvar(symfil, sym^.val) { output symbol value }

end;

{******************************************************************************

Output constant rlds

Outputs all the stand-alone rlds, which are what make up the relocation
dictionary when all the expressions are resolved. If the rld is not an
address or variable space rld (which may change further due to relocation),
or is an offset entry, and is defined (is a constant rld), it is not output.
This can happen because the patch location in the output object file has
already been modified, and will never change again. This applies even to offset
entries, because an offset is independent to the location of the program.

******************************************************************************}

procedure outrlds;

var rp: rldptr; { pointer for rlds }

begin

   rp := rldtab; { index rld top }
   while rp <> nil do begin { traverse }

      if rp^.def and (rp^.adf or rp^.vrs) and 
         not (rp^.im = imsgof) and not (rp^.im = imnsof) then
         { defined address space or variable space, and not offset.
           We don't output signed offset because these don't change 
           after initial computation }
         wrnrld(rp);
      rp := rp^.next { link next entry }

   end

end;

{******************************************************************************

Write rlds for symbol

Writes all rlds indexing the given symbol.
The time taken to search through the rld table for links could be mitigated
by keeping a linked list of referencing rlds.

******************************************************************************}

procedure outrld(sym: symptr); { symbol to output rlds for }

var rp: rldptr; { pointer for rlds }

begin

   rp := rldtab; { index top of rlds }
   while rp <> nil do begin { traverse }

      if rp^.inssym = sym then wrnrld(rp); { if references symbol, output }
      rp := rp^.next { link next }

   end

end;

{******************************************************************************

Output skeletal symbol

******************************************************************************}

procedure wrsym(sym: symptr); { symbol to output }

var tp: symptr; { pointer for symbol }

begin

   if ftrim and sym^.def and not sym^.gbl and not sym^.ext then begin 

      { output in "trim" mode }
      getsym(tp); { get a temp symbol }
      tp^ := sym^; { copy entire symbol }
      tp^.lab[1] := ' '; { but remove label }
      wrnsym(tp); { write symbol }
      putsym(tp); { release entry }
      if sym^.lft <> nil then wrsym(sym^.lft); { output skeleton of left }
      if sym^.rgt <> nil then wrsym(sym^.rgt) { output skeleton of left }

   end else { output in normal mode }
      if sym^.lab[1] = ' ' then begin { output normal if constant }

         wrnsym(sym); { output top symbol }
         if sym^.lft <> nil then wrsym(sym^.lft); { output left if exists }
         if sym^.rgt <> nil then wrsym(sym^.rgt) { output left if exists }

      end else begin { output skeleton }

         getsym(tp); { get a temp symbol }
         tp^ := sym^; { copy entire symbol }
         tp^.def := false; { but set undefined }
         wrnsym(tp); { write symbol }
         putsym(tp); { release entry }

      end

end;

{******************************************************************************

Trim rlds

The rlds indexing the symbol are changed to constant rlds by placing the
symbols value in the rld entry, and changing the rld type.

******************************************************************************}

procedure trmrld(sym: symptr); { symbol to trim rlds for }

var rp: rldptr; { index for rlds }

begin

   rp := rldtab; { index top rld }
   while rp <> nil do begin { traverse }

      if rp^.inssym = sym then begin { found a referencing rld }

         rp^.val := sym^.val; { place symbol value }
         rp^.inssym := nil; { clear symbol linkage }
         rp^.def := true; { set defined }
         rp^.adf := sym^.add; { copy address space flag }
         rp^.vrs := sym^.vrs { copy variable space flag }

      end;
      rp := rp^.next { link next entry }

   end

end;

{******************************************************************************

Output symbols file

Outputs the final symbols deck and rlds. Each symbol is examined, and written
to the output symbols file. Any rlds indexing the symbol are then output.
Then the symbols dependance tree (the subentrys that define the value of the
symbol) are output in "skeletal" form. "skeletal" means they are converted
to undefined placeholders. These entries only serve to match up to the
"master" entries when the symbols file is read back in again, and so recreate
the tree.
After all symbols are output, the uncommited rlds (constant rlds) are output.
If the "trim" flag is on, we modify how we output symbols. If the symbol is
global or external, it is output normally, as such symbols cross module
barriers. If the symbol is defined, it will not appear at all in the output
file, and all it's associated rlds are changed to constant rlds.
This is possible because the value of the symbol will no longer change, and
may not be referenced further.

******************************************************************************}

procedure outsym;

var sp, tp: symptr;  { pointer for symbols }

begin

   sp := symtab; { index top of symbols }
   while sp <> nil do begin { traverse symbols }

      if ftrim then begin { output in "trim" mode }

         if sp^.ext or sp^.gbl then begin 

            { global or external, output normally }
            wrnsym(sp); { output symbol }
            outrld(sp); { output associated rlds }
            if sp^.lft <> nil then wrsym(sp^.lft); { output skeleton of left }
            if sp^.rgt <> nil then wrsym(sp^.rgt) { output skeleton of left }

         end else if sp^.def then { symbol defined, eliminate entirely }
            trmrld(sp) { remove associated rlds, as they have been resolved }
         else begin { symbol to be "trimmed", or converted to constant }

            getsym(tp); { get a temp symbol }
            tp^ := sp^; { copy entire symbol }
            tp^.lab[1] := ' '; { but remove label }
            wrnsym(tp); { write symbol }
            putsym(tp); { release entry }
            outrld(tp); { output associated rlds }
            if sp^.lft <> nil then wrsym(sp^.lft); { output skeleton of left }
            if sp^.rgt <> nil then wrsym(sp^.rgt) { output skeleton of left }

         end

      end else begin { output in normal mode }

         wrnsym(sp); { output symbol }
         outrld(sp); { output associated rlds }
         if sp^.lft <> nil then wrsym(sp^.lft); { output skeleton of left }
         if sp^.rgt <> nil then wrsym(sp^.rgt) { output skeleton of left }

      end;
      sp := sp^.next { link next symbol }
         
   end;
   outrlds; { output current rlds }
   wrtbyt(symfil, ord(obend)) { write end of file }

end;

{******************************************************************************

Process object

Copies the input object file to the output object file. While copying, any
pending rld's are "mixed" into the output object file.

******************************************************************************}

procedure prcobj;

var objlen: integer; { output bytes count }
    b:      byte;    { I/O byte holder }
    bytes:  integer; { number of bytes in bit field }
    v:      integer; { insertion value }
    bak:    integer; { backing value }
    t:      integer; { temp }
    i:      integer; { index }
    proc:   boolean; { processed flag }

begin

   objlen := cursrc^.plen; { get the length of this input object }
   while objlen <> 0 do begin { read object bytes }

      proc := false; { set next not processed }
      if rldinx <> nil then { there is a next rld entry }
         if rldinx^.add = prgmc then begin { found an rld patchpoint, process }

         { find byte length of insertion field }
         bytes := (rldinx^.len+rldinx^.str) div 8; { find total byte length }
         if ((rldinx^.len+rldinx^.str) mod 8) <> 0 then 
            bytes := bytes+1; { round up }
         if rldinx^.inssym <> nil then { symbol exists }
            v := rldinx^.inssym^.val { value is in symbol }
         else v := rldinx^.val; { value is constant }
         if (rldinx^.im = imsgof) or (rldinx^.im = imnsof) then begin
   
            { type is signed offset, find displacement }
            v := v-(prgmc+bytes+rldinx^.cof)
   
         end;
         t := v; { copy value }
         { move off all bits to output, which should leave only 0 or -1 }
         for i := 1 to rldinx^.len do t := t div 2;
         if (t <> 0) and (t <> -1) then begin { value overflow }
   
            errval := v; { place error value }
            errbits := rldinx^.len; { place error bit length }
            prterr(efldovf); { value overflows }
   
         end;
         inpbak(bak, rldinx^.big, bytes); { get backing value }
         objlen := objlen-bytes; { find advance in input }
         prgmc := prgmc+bytes; { find advance in program }
         { output final composite }
         outbit(v, bak, rldinx^.big, rldinx^.str, rldinx^.len);
         rldinx := rldinx^.next; { index next rld entry }
         proc := true { set processed }
         
      end;
      if not proc then begin { transfer input to output object bytes }

         readbyt(objinp, b); { get an input byte }
         wrtbyt(objout, b); { output to final }
         prgmc := prgmc+1; { advance final program counter }
         objlen := objlen-1 { count input bytes }

      end

   end

end;

{******************************************************************************

Originate module

Sets the offsets required to acheive the program and variable locations LN is
given. By default, the program frame is located at 0, and the variable frame is
placed at the end of that. However, the program frame or the variable frame
or both can be set anywhere. If the user has set a variable frame, then the
"variable after program" mode is overridden, and the variable frame will be
located where specified.

******************************************************************************}

procedure origin;

begin

   poff := pgmloc; { set program offset }
   if fvset then voff := varloc { set variable offset to specified }
   else voff := pend^.val+poff; { set variable space to the end of program }
   if not fsupp then begin { place final output module definitions }

      srclst^.plen := pend^.val-pstr^.val; { place program length }
      srclst^.vlen := vend^.val-vstr^.val  { place variable length }

   end;
   adjusts { run offset pass }

end;

{******************************************************************************

Sort rld table

Sorts the rld table into address acending order. This is done so that the
entries appear in order when we process the object.
Since we really want to do a quicksort for speed, what we do is to create a
custom array with the number of rld entries we need, then quicksort that.
The hit for this is a pointer word per rld, and this only exists during this
sort function.
Note: there is no way to dynamically allocate in SVS Pascal, so I used a fixed
array. This should be replaced with dynamic allocation later.

******************************************************************************}

procedure srtrld;

const maxsrt = 100000; { maximum size of rld table we can sort }

type srtinx = 1..maxsrt; { index for sort array }

var rp:     rldptr;                      { rld pointers }
    srttbl: array [1..maxsrt] of rldptr; { rld sorting array }
    i:      srtinx;                      { index for that }

{ perform quicksort }

procedure sort(l, r: srtinx);

var i, j: integer; { table indexes }
    x, w: rldptr;  { entry holders }

begin

   i := l; { set indexes to min and max }
   j := r;
   x := srttbl[(l+r) div 2]; { pick up the middle element }
   repeat

      { find lower entry out of place with respect to x }
      while srttbl[i]^.add > x^.add do i := i+1;
      { find upper entry out of place with respect to x }
      while x^.add > srttbl[j]^.add do j := j-1;
      { perform exchange }
      if i <= j then begin { exchange elements }

         w := srttbl[i]; 
         srttbl[i] := srttbl[j];
         srttbl[j] := w;
         i := i+1;
         j := j-1

      end

   until i > j;
   if l < j then sort(l, j); { sort lower partition }
   if i < r then sort(i, r) { sort upper partition }

end;

begin

   i := 1; { index 1st array position }
   rp := rldtab; { index 1st entry }
   while rp <> nil do begin { copy all pointers to array }

      if i = maxsrt then prterr(erldovf); { overflow, error } 
      srttbl[i] := rp; { place rld pointer }
      rp := rp^.next; { next entry }
      i := i+1

   end;
{   sort(1, i-1);} { perform sort }
{   rldtab := nil; { clear destination list }
   { just to make things easier, we sorted the list for decending order,
     then insert it backwards }
{   for i := 1 to i-1 do begin { copy table to list }

{;write('address = '); prthex(8, srttbl[i]^.add); writeln;
{      srttbl[i]^.next := rldtab; { link entry into list at top }
{      rldtab := srttbl[i]

   end
}

end;

{******************************************************************************

Perform symbol operator

If the operands of a symbol are defined, then the operation on a symbol is
performed. On program or variable space values, these operations must be
done on every link resolve operation (because they can always be relocated
again). Otherwise, this may be the final resolution of the symbol.

******************************************************************************}

procedure symopr(sym: symptr); { symbol to operate on }

var def: boolean; { operand(s) are defined flag }

begin

   { validate the correct parameters exist }
   if (sym^.opr in [onot, oneg]) and 
      ((sym^.lft = nil) or (sym^.rgt <> nil)) then fprterr(esymfmt)
   else if (sym^.opr in [oadd, osub, omult, odiv, omod, oshl, oshr, oand, oor,
            oxor]) and
           ((sym^.lft = nil) or (sym^.rgt = nil)) then fprterr(esymfmt)
   else if (sym^.opr = onop) and 
           ((sym^.lft <> nil) or (sym^.rgt <> nil)) then fprterr(esymfmt);
   def := true; { set operand(s) defined }
   { check left branch exists and is defined }
   if sym^.lft <> nil then if not sym^.lft^.def then def := false;
   { check right branch exists and is defined }
   if sym^.rgt <> nil then if not sym^.rgt^.def then def := false;
   if def then begin { operand(s) defined }

      case sym^.opr of { operation }

         onop:  ; { no operation }
         oadd:  sym^.val := sym^.lft^.val+sym^.rgt^.val; { add }
         osub:  sym^.val := sym^.lft^.val-sym^.rgt^.val; { subtract }
         omult: sym^.val := sym^.lft^.val*sym^.rgt^.val; { multiply }
         odiv:  sym^.val := sym^.lft^.val div sym^.rgt^.val; { divide }
         omod:  sym^.val := sym^.lft^.val mod sym^.rgt^.val; { modulo }
         oshl:  begin { shift left }
     
            sym^.val := sym^.lft^.val;
            while sym^.rgt^.val > 0 do sym^.val := sym^.val*2
     
         end;
         oshr:  begin { shift right }
     
            sym^.val := sym^.lft^.val;
            while sym^.rgt^.val > 0 do sym^.val := sym^.val div 2
     
         end;
         oand:  sym^.val := sym^.lft^.val and sym^.rgt^.val; { and }
         oor:   sym^.val := sym^.lft^.val or sym^.rgt^.val; { or }
         { exclusive or }
         oxor:  sym^.val := (sym^.lft^.val and not sym^.rgt^.val) or
                            (not sym^.lft^.val and sym^.rgt^.val);
         onot:  sym^.val := not sym^.lft^.val; { not }
         oneg:  sym^.val := -sym^.lft^.val { negate }

      end;
      if sym^.opr <> onop then { not a simple symbol }
         sym^.def := true { set resulting symbol now defined }

   end

end;

{******************************************************************************

Reduce symbol

Performs any operations possible on the given symbol, and frees of any entries
as possible.

******************************************************************************}

procedure redsym(sym: symptr);

{ attempt to free up symbols entry }

procedure free(var sym: symptr); 

begin

   if sym <> nil then { there is a symbol }
      if sym^.lab[1] = ' ' then begin

      delsym(sym); { delete entry from symbols list }
      putsym(sym); { release symbol entry }
      sym := nil { remove index }

   end

end;

begin

   if sym^.lft <> nil then begin { left branch exists }

      { add any attributes of subsymbol to this symbol }
      if sym^.lft^.add then sym^.add := true;
      if sym^.lft^.vrs then sym^.vrs := true;
      redsym(sym^.lft) { reduce }

   end;
   if sym^.rgt <> nil then begin { right branch exists }

      { add any attributes of subsymbol to this symbol }
      if sym^.rgt^.add then sym^.add := true;
      if sym^.rgt^.vrs then sym^.vrs := true;
      redsym(sym^.rgt) { reduce }

   end;
   symopr(sym); { perform operation on current symbol }
   if sym^.def and not (sym^.add or sym^.vrs) then begin 

      { value is defined, and not in address or variable space }
      sym^.opr := onop; { reduce to simple symbol }
      free(sym^.lft); { attempt to free left }
      free(sym^.rgt)  { attempt to free right }

   end

end;

{******************************************************************************

Reduce symbols

Performs any operations possible on the symbols deck, then disposes of any 
freed entries.

******************************************************************************}

procedure reduce;

var sp: symptr; { pointer for symbols }

begin

   sp := symtab; { index top of symbols table }
   while sp <> nil do begin { traverse }

      redsym(sp); { reduce symbol }
      sp := sp^.next { link next symbol }

   end

end;

{******************************************************************************

Append symbol table

The start and end addresses for the program and variable spaces in the
current symbols deck are recalculated so that the frames stack ontop of the
old saved deck. Then, the current symbols and rld decks are recalcuated entry
by entry to match the new frame addresses. 
Also assigns the current module lengths.

******************************************************************************}

procedure apnsym;

begin

   { find old pend - new pstr, to get offset that will place new code at old
     pend }
   poff := pendod-pstrnw;
   { find old vend - new vstr, to get offset that will place new code at old
     vend }
   voff := vendod-vstrnw;
   cursrc^.plen := pendnw-pstrnw; { place program length of module }
   cursrc^.vlen := vendnw-vstrnw; { place variable length of module }
   adjusts; { adjust current deck by offsets }
   pstrod := 0; { find combined old and new pstr }
   pendod := pendod+(pendnw-pstrnw); { find combined old and new pend }
   vstrod := 0; { find combined old and new vstr }
   vendod := vendod+(vendnw-vstrnw); { find combined old and new vend }
   pstr^.val := pstrod; { copy values to the actual symbol entries }
   pend^.val := pendod;
   vstr^.val := vstrod;
   vend^.val := vendod

end;

{******************************************************************************

Check link parameter

Checks if the given symbol is one of the link parameters:

   _pstr - Program start
   _pend - Program end
   _vstr - Variable start
   _vend - Variable end

If so, then these symbols are processed specially. First, the value of the
symbol is divorced from the symbol entry itself, so that we may have only
one symbol by that name in the entire symbol table(s). The value is placed
as the "new" value. Then, if the symbol is the first such symbol to appear,
it is placed as the master entry. Otherwise, it is disposed of and the old
master entry returned instead.

******************************************************************************}

procedure chkpar(var sym: symptr; { symbol to check for, returns master }
                 var fnd: boolean); { symbol is link parameter }

begin

   fnd := false; { set no parameter found }
   if cmpequ(sym^.lab, '_pstr     ') then begin { program start }

      { check defined, address space, global }
      if not (sym^.def and sym^.add and sym^.gbl) then fprterr(esymfmt);
      if pstrf then fprterr(esymfmt); { more than one in file }
      pstrf := true; { set parameter found }
      pstrnw := sym^.val; { set new program start value }
      if pstr = nil then begin { no previous entry }

         sym^.next := symtab; { link into symbols table }
         symtab := sym;
         pstr := sym { set master }

      end else begin { duplicate entry }

         putsym(sym); { dispose of new symbol }
         sym := pstr { return old master }

      end;
      fnd := true { set parameter found }

   end else if cmpequ(sym^.lab, '_pend     ') then begin { program end }

      { check defined, address space, global }
      if not (sym^.def and sym^.add and sym^.gbl) then fprterr(esymfmt);
      if pendf then fprterr(esymfmt); { more than one in file }
      pendf := true; { set parameter found }
      pendnw := sym^.val; { set new program end value }
      if pend = nil then begin { no previous entry } 

         sym^.next := symtab; { link into symbols table }
         symtab := sym;
         pend := sym { no previous entry, set master }

      end else begin { duplicate entry }

         putsym(sym); { dispose of new symbol }
         sym := pend { return old master }

      end;
      fnd := true { set parameter found }

   end else if cmpequ(sym^.lab, '_vstr     ') then begin { variable start }

      { check defined, variable space, global }
      if not (sym^.def and sym^.vrs and sym^.gbl) then fprterr(esymfmt);
      if vstrf then fprterr(esymfmt); { more than one in file }
      vstrf := true; { set parameter found }
      vstrnw := sym^.val; { set new variable start value }
      if vstr = nil then begin { no previous entry }

         sym^.next := symtab; { link into symbols table }
         symtab := sym;
         vstr := sym { set master }

      end else begin { duplicate entry }

         putsym(sym); { dispose of new symbol }
         sym := vstr { return old master }

      end;
      fnd := true { set parameter found }

   end else if cmpequ(sym^.lab, '_vend     ') then begin { variable end }

      { check defined, variable space, global }
      if not (sym^.def and sym^.vrs and sym^.gbl) then fprterr(esymfmt);
      if vendf then fprterr(esymfmt); { more than one in file }
      vendf := true; { set parameter found }
      vendnw := sym^.val; { set new variable end value }
      if vend = nil then begin { no previous entry }

         sym^.next := symtab; { link into symbols table }
         symtab := sym;
         vend := sym { no previous entry, set master }

      end else begin { duplicate entry }

         putsym(sym); { dispose of new symbol }
         sym := vend { return old master }

      end;
      fnd := true { set parameter found }

   end

end;

{******************************************************************************

Read rlds attached to symbol

Reads any rld's that may follow a symbol, and attaches them to the given
symbol, as the symbol provides the solution for that rld.

******************************************************************************}

procedure rdrlds(sym: symptr); { symbol to attach to }

begin

   while nxtobj = obrld do begin { read rlds }

      nxtrld^.next := rldtab; { link into current rld table }
      rldtab := nxtrld;
      adjrld(nxtrld); { adjust entry }
      nxtrld^.inssym := sym; { link to symbol }
      rdnxt { read next entry }

   end

end;

{******************************************************************************

Read symbol

Reads a symbol entry from the symbols file. The next symbol is read, and also
any symbols in "subtrees" under the symbol. In this way, the entire expression
tree that represents an undefined symbol can be read. Also reads any rld's
referencing the symbol, or symbols under it.
Returns the symbol entry, as it is entered into the symbol table.

******************************************************************************}

procedure rdsym(var sym: symptr);

var linkf:  boolean; { symbol is link parameter flag }
    sp, fp: symptr;  { symbol table pointers }
    saved:  boolean; { symbol is from saved flag }

begin

   { check valid object }
   if (nxtobj <> obsym) and (nxtobj <> obcst) then fprterr(esymfmt);
   sym := nxtsym; { set entry pointer }
   rdnxt; { get next object }
   adjsym(sym); { adjust symbol entry }
   linkf := false; { set not a link parameter }
   if sym^.lab[1] <> ' ' then { a labeled symbol }
      chkpar(sym, linkf); { check the entry is a link parameter }
   if not linkf then begin { standard symbol }

      { search old table for symbol }
      fp := nil; { set found pointer null }
      if sym^.lab[1] <> ' ' then begin { is a labeled symbol }

          sp := symsav; { index top of saved symbols }
          saved := true; { set symbol from saved table }
          while sp <> nil do begin { traverse symbols }
      
             if labequ(sym^.lab, sp^.lab) then fp := sp; { save matching symbol }
             sp := sp^.next { index next symbol }
    
          end;
          if fp = nil then begin { search new table for symbol }
    
             fp := nil; { set found pointer null }
             sp := symtab; { index top of symbols }
             saved := false; { set symbol from new table }
             while sp <> nil do begin { traverse symbols }
         
                if labequ(sym^.lab, sp^.lab) then fp := sp; { save matching symbol }
                sp := sp^.next { index next symbol }
       
             end
    
          end

      end;
      if fp <> nil then begin { symbol found }

         if sym^.def and fp^.def and not (sym^.err or fp^.err) then begin 

            { duplicate definition }
            errlab := sym^.lab; { place error label }
            prterr(edupsym); { duplicate symbol }
            sym^.err := true; { set error already reported }
            fp^.err := true

         end else 
            { if in security mode, and mating two symbols from different decks, 
              checks that both operands are either global or external, and
              flags error if not }
            if fsecr and saved and not (sym^.err or fp^.err) and
               not (sym^.gbl or sym^.ext) and 
               not (fp^.gbl or fp^.ext) then begin { error }

            errlab := sym^.lab; { place error label }
            prterr(engore); { symbol must be global or external }
            sym^.err := true; { set error already reported }
            fp^.err := true

         end;
         if sym^.def and not fp^.def then begin 

            { new symbol is defined, and the old symbol is not }
            if saved then { symbol came from saved table }
               movsym(fp); { if old in saved table, move it to new table }
            { copy new symbol parameters to old entry }
            fp^.opr := sym^.opr;
            fp^.def := sym^.def;
            fp^.add := sym^.add;
            fp^.gbl := sym^.gbl;
            fp^.ext := sym^.ext;
            fp^.vrs := sym^.vrs;
            fp^.val := sym^.val

         end;
         { replace new symbol with old symbol }
         putsym(sym); { dispose of new symbol }
         sym := fp { replace with existing symbol }

      end else begin { link unique symbol into new symbols table }

         sym^.next := symtab; { link into table }
         symtab := sym

      end
         
   end;
   rdrlds(sym); { read any associated rlds }
   if sym^.opr <> onop then begin { the symbol is an expression head }

      rdsym(sp); { read left symbol }
      sym^.lft := sp; { place }
      if sym^.opr <> onop then begin { right branch exists }

         rdsym(sp); { read right symbol }
         sym^.rgt := sp { place }

      end

   end

end;

{******************************************************************************

Read symbols file

Reads in the symbols and rld entries from the currently open symbols file,
and creates in memory tables.

******************************************************************************}

procedure rdsyms;

var sym: symptr; { pointer for return symbol (unused) }

begin

   pstrf  := false; { set program start found false }
   pendf  := false; { set program end found false }
   vstrf  := false; { set variable start found false }
   vendf  := false; { set variable end found false }
   rdnxt; { start lookahead mechanisim }
   while nxtobj <> obend do begin { process entries }

      if (nxtobj = obsym) or (nxtobj = obcst) then 
         { object is symbol or constant }
         rdsym(sym) { read symbol entry }
      else if nxtobj = obcrld then begin { rld }

         nxtrld^.next := rldtab; { link into current rld table }
         rldtab := nxtrld;
         adjrld(nxtrld); { adjust entry }
         rdnxt { read next entry }

      end else fprterr(esymfmt) { rlds should not be floating loose ! }

   end;
   { check all link parameters existed in file read }
   if not (pstrf and pendf and vstrf and vendf) then fprterr(esymfmt)

end;

end.
